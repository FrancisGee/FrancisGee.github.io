---

layout: post
title: 动态规划入门
date: 2016-12-25
tags: [algorithms]

---

目录

* TOC 
{:toc}

>不出意外，这应该是2016年的最后一篇博客了。在2016年投入在算法上的时间挺多的，也借此在2017年来临之际，
将**动态规划**(Dynamic programming),作为新手，是不可能一下子就把**动态规划**问题想清楚和解决清楚的。

## 动态规划给人的印象
**动态规划**给人的感觉是从**递归**这个问题的优化入手的，在这一方面最经典的例子(*问题一*)为斐波拉契数列的求解问题。动态规划给人一种用空间换时间的错觉，因为**动态规划**将子问题的解存储下来，避免重复计算。但解决动态规划问题的本质有两点，第一点为**状态**是什么，第二点为**状态转移方程**是什么。

>维基百科上说，若要解决一个给定问题，我们需要解其不同部分的子问题，再合并子问题得到原问题的解，许多子问题非常相似，动态规划试图仅仅解决每个子问题一次。一旦某个给定的子问题的解已经算出，可以将其记忆化存储，以便下一次需要解决同一个子问题时直接查表。从另一个角度上来说，待解决的问题具有很多重叠子问题，所以用已经算出子问题的解来避免重复计算。

理论说的再多也没有用，本博文用四个问题(斐波拉契数列问题，最少硬币问题，爬楼梯问题，卖股票问题)来多方面的解读**动态规划**问题。

## 斐波拉契数列问题

**斐波拉契数列问题**是一个经典的递归问题，但是用递归解法太耗时间，所以采用**动态规划**来提高算法运行速度。

用递归解法求解斐波拉契数列问题:

*Code*:

```java
		public int fib(int n){
			if(n == 0 || n == 1)  return n;
			return fib(n-1)+fib(n-2);
		}
```


当n=5时，fib(5)的计算过程如下:
1. fib(5)
2. fib(4) + fib(3)
3. (fib(3) + fib(2)) + (fib(2) + fib(1))
4. ((fib(2) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))
5. (((fib(1) + fib(0)) + fib(1)) + (fib(1) + fib(0))) + ((fib(1) + fib(0)) + fib(1))

可以看到进行了很多重复计算，浪费时间，这个时候要引入**动态规划**

*Code*:

```java
		public int fib2(int n){
			int[] map = new int[n+1];
			map[0] = 0;
			map[1] =1;
			for(int i =2; i<=n;i++){
				map[i] = map[i-1]+map[i-2];
			}
			return map[n];
		}

```

将已经解决的子问存储起来，避免重复计算，并且时间效率高了很多。

接下来的问题将不会讨论低效率的递归解法，直接对待解决的问题用**动态规划**分析。

## 凑硬币问题

凑银币问题是一个比较适合入门的**动态规划**问题。

**问题描述**：如果我们有面值为1元、２元和5元的硬币若干枚，如何用最少的硬币凑够11元？

首先我们思考一个问题，如何用最少的硬币凑够i元(i<11)？为什么要这么问呢？ 

**两个原因**：
1. 当我们遇到一个大问题时，总是习惯把问题的规模变小，这样便于分析讨论。
2. 这个规模变小后的问题和原来的问题是同质的，除了规模变小，其它的都是一样的， 本质上它还是同一个问题(规模变小后的问题其实是原问题的子问题)。

>好了，让我们从最小的i开始吧。当i=0，即我们需要多少个硬币来凑够0元。 由于1，3，5都大于0，即没有比0小的币值，因此凑够0元我们最少需要0个硬币。 (这个分析很傻是不是？别着急，这个思路有利于我们理清动态规划究竟在做些什么。) 这时候我们发现用一个标记来表示这句“凑够0元我们最少需要0个硬币。”会比较方便， 如果一直用纯文字来表述，不出一会儿你就会觉得很绕了。那么， 我们用d(i)=j来表示凑够i元最少需要j个硬币。于是我们已经得到了d(0)=0， 表示凑够0元最小需要0个硬币。当i=1时，只有面值为1元的硬币可用， 因此我们拿起一个面值为1的硬币，接下来只需要凑够0元即可，而这个是已经知道答案的， 即d(0)=0。所以，d(1)=d(1-1)+1=d(0)+1=0+1=1。当i=2时， 仍然只有面值为1的硬币可用，于是我拿起一个面值为1的硬币， 接下来我只需要再凑够2-1=1元即可(记得要用最小的硬币数量)，而这个答案也已经知道了。 所以d(2)=d(2-1)+1=d(1)+1=1+1=2。一直到这里，你都可能会觉得，好无聊， 感觉像做小学生的题目似的。因为我们一直都只能操作面值为1的硬币！耐心点， 让我们看看i=3时的情况。当i=3时，我们能用的硬币就有两种了：1元的和3元的( 5元的仍然没用，因为你需要凑的数目是3元！5元太多了亲)。 既然能用的硬币有两种，我就有两种方案。如果我拿了一个1元的硬币，我的目标就变为了： 凑够3-1=2元需要的最少硬币数量。即d(3)=d(3-1)+1=d(2)+1=2+1=3。 这个方案说的是，我拿3个1元的硬币；第二种方案是我拿起一个3元的硬币， 我的目标就变成：凑够3-3=0元需要的最少硬币数量。即d(3)=d(3-3)+1=d(0)+1=0+1=1. 这个方案说的是，我拿1个3元的硬币。好了，这两种方案哪种更优呢？ 记得我们可是要用最少的硬币数量来凑够3元的。所以， 选择d(3)=1.

>怎么来的呢？具体是这样得到的：d(3)=min{d(3-1)+1, d(3-3)+1}。

>上文中d(i)表示凑够i元需要的最少硬币数量，我们将它定义为该问题的”状态”,根据子问题定义状态。你找到子问题，状态也就浮出水面了。 最终我们要求解的问题，可以用这个状态来表示：d(11)，即凑够11元最少需要多少个硬币。

>那状态转移方程是什么呢？既然我们用d(i)表示状态，那么状态转移方程自然包含d(i)， 上文中包含状态d(i)的方程是：d(3)=min{d(3-1)+1, d(3-3)+1}。没错， 它就是状态转移方程，描述状态之间是如何转移的。当然，我们要对它抽象一下，

>d(i)=min{ d(i-vj)+1 }，其中i-vj >=0，vj表示第j个硬币的面值;

>伪代码如下：

```

Set Min[i] equal to Infinity for all of i
Min[0] = 0

For i = 1 to S
For j = 0 to N-1
	If(Vj<=i AND Min[i-Vj]+1<Min[i])
Then Min[i]=Min[i-Vj]+1

Output MIn[S]

```

*Code*

```java
	public int coinNumber(int num){
			int[] min = new int[num+1];
			int[] coin = new int[3];
			coin[0] = 1;
			coin[1] = 2;
			coin[2] = 5;
			min[0] = 0;
				
			for(int i =1;i<=num;i++){
				min[i] = Integer.MAX_VALUE;
			}

		
			for(int i =1 ; i<=num;i++){
				for(int j = 0;j<=2;j++){
					if((coin[j]<=i)&&(min[i-coin[j]]+1<min[i])  ){
						min[i] = min[i-coin[j]]+1;
					}
				}
			}
			return min[num];
		}


```

## 卖股票问题

**问题描述**: 给一段时间的股票价格信息，用数组表示，其中数组中的第i个元素表示给定股票第i天的价格，现在你要做的事情是在合适的卖出股票获得最大收益，或者不进行任何交易(如果在这段时间股票不可能有收益)。

*Note*: 股票绝对是**低买高卖**

这个问题看上去的难点在于不知道什么时候入手股票，什么时候抛售股票，用**动态规划**的思想对数组中每个元素中都有两种情况：

1. 比当前最低股票价格便宜，那么就更改当前最低股票的价格
2. 比当前最低股票的价格高(股票在升值)--->当前抛售的利润大于此时的利润，那么更改所或利润的最大值

```java
 		public int maxProfit(int[] prices) {
		    if(prices.length == 0){
		        return 0;
		    }
		    
		    int max = 0 , min = prices[0];
		    int profit = 0;
		    
		    for(int i = 1; i < prices.length; i++){
		       if(prices[i] < min){
		           min = prices[i];
		       }
		       else{
		           if(prices[i] - min > profit){
		               profit = prices[i] - min;
		           }
		       }
		    }
      	  return profit;

```

## 爬楼梯问题

**问题描述**:有一个人要爬楼梯，总共有n级台阶，每次只能爬一级台阶或跳二级台阶，有多少种方式可以到达台阶的顶部？

这个问题一看就可以用**递归**解决，要达到n级台阶有两种方式：
1.此时已经在n-1级台阶，只需要爬一步，就可以到台阶顶
2.此时已经在n-2级台阶，只需要跳两步，就可以到台阶顶

将这两种方式累加起来，就是爬到n级台阶总共有的方式

在这里，我肯定不会用**递归**的方式来解决，那样耗时间，这里还是用**动态规划**的思想。

这个问题可以**归约**为**斐波拉契数列**的**动态规划**问题，这里为了降低空间复杂度，在此基础上又进行了优化。

```java

 		public int climbStairs(int n) {
		    //base case
		    if(n <= 0) return 0;
		    if(n == 1) return 1;
		    if(n == 2) return 2;
		    
		    int one_step_before = 2;
		    int two_step_before = 1;
		    int all_ways = 0;
		    
		    for(int i = 2; i< n; i++){
		        all_ways = one_step_before + two_step_before;
		        two_step_before = one_step_before;
		        one_step_before = all_ways;
		    }
		    
		    return all_ways;
        
    }

```

## 总结


初次学习动态规划问题，理解的可能不是那么深入，或者有纰漏都是在所难免的。
从上面这些问题可以看到，**动态规划**具有很强的**记忆性存储**特性，某些递归问题可以用**动态规划**问题解决。

这里抛出一个疑问，在那个凑硬币的问题中，如果是２元，３元，５元。那么问题怎么解决，因为不可能凑出１元。

目前对于这种情况，我采取的修改为：


```

Set Min[i] equal to Infinity for all of i
Min[0] = 0

**Min[1] = 0**

**For i = 2 to S**
For j = 0 to N-1
	If(Vj<=i AND Min[i-Vj]+1<Min[i])
Then Min[i]=Min[i-Vj]+1
Output Min[S]

```
## 彩蛋

在**凑硬币**的问题中，仅仅考虑了查询的时间复杂度，而没有考虑建表初始化的复杂度。当要凑硬币的数值很大时，可以考虑将面额降序排列，然后从最大的面额开始进行查询比较，节约时间，参考的最后一篇文章可以作为参考。


## 参考
* [动态规划：从新手到专家](http://www.hawstein.com/posts/dp-novice-to-advanced.html)
* [Dynamic programming Wiki](https://en.wikipedia.org/wiki/Dynamic_programming#Fibonacci_sequence)
* [Dynamic Programming – From Novice to Advanced](https://www.topcoder.com/community/data-science/data-science-tutorials/dynamic-programming-from-novice-to-advanced/)
* [Dynamic Programming – Minimum Number of Coins](http://techieme.in/minimum-number-of-coins/)






